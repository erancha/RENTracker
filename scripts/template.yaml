AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: RENTracker - AWS/React/WebSockets-based serverless rental tracking application

Parameters:
  ExistingAppPrivateSubnetId:
    Type: String
    Description: 'ID of an existing private subnet for app/business logic Lambda functions (leave empty to create a new one)'
    Default: ''
  ExistingAppSG:
    Type: String
    Description: 'App/business logic Lambda functions security group (leave empty to create a new one)'
    Default: 'sg-99999999' # must be set with a proper value from scripts\dev-build-deploy.ps1 when ExistingAppPrivateSubnetId is set.

  ExistingRedisAddress:
    Type: String
    Description: 'Address of an existing Redis server'
  ExistingRedisPassword:
    Type: String
    Description: 'Password of an existing Redis server'
    NoEcho: true # Do not show the password in the CloudFormation console or logs
    Default: ''

  # Lambda Layer ARNs
  ExistingAwsSdkV3LayerArn:
    Type: String
    Description: 'ARN of existing AWS SDK v3 Layer'
    Default: ''
  ExistingRedisClientLayerArn:
    Type: String
    Description: 'ARN of existing Redis Client Layer'
    Default: ''
  ExistingWebsocketsConnectionsLayerArn:
    Type: String
    Description: 'ARN of existing Connections Usernames Layer'
    Default: ''
  ExistingCommandsHandlersLayerArn:
    Type: String
    Description: 'ARN of existing Commands Handlers Layer'
    Default: ''
  ExistingDbDataLayerArn:
    Type: String
    Description: 'ARN of existing DB Data Layer'
    Default: ''
  ExistingDocumentUtilsLayerArn:
    Type: String
    Description: 'ARN of existing Document Utils Layer'
    Default: ''
  ExistingCorsHeadersLayerArn:
    Type: String
    Description: 'ARN of existing CORS Headers Layer'
    Default: 'arn:aws:lambda:eu-central-1:575491442067:layer:CorsHeadersLayer:28'

  StageName:
    Type: String
    AllowedValues: ['dev', 'prod']
    Default: 'dev'
  CustomDomainName:
    Description: 'The custom domain name (optional)'
    Type: String
    Default: ''
    AllowedPattern: '^$|(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$'
    ConstraintDescription: 'Must be a valid domain name or empty'
  CertificateArn:
    Description: 'Certificate ARN for the custom domain (optional)'
    Type: String
    Default: ''
  ExistingUserPoolId:
    Description: 'ID of an existing Cognito User Pool'
    Type: String
  ExistingCognitoDomain:
    Description: 'Existing Cognito Domain'
    Type: String

  AllowOnlyCloudfrontOrigin:
    Description: 'Allow only CloudFront origin'
    Type: String
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'
  ApiGatewayCorsAllowedMethods:
    Type: String
    Default: "'GET,POST,PUT,DELETE,OPTIONS'"
    Description: 'Allowed HTTP methods for CORS'
  ApiGatewayCorsAllowedHeaders:
    Type: String
    Default: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    Description: 'Allowed headers for CORS'
  ApiGatewayCorsAllowedOrigins:
    Type: String
    Default: "'*'" # TODO
    Description: 'Allowed origins for CORS'

  AdminUserId:
    Description: 'User id of the admin'
    Type: String
    Default: '53b408f2-d071-70e2-f4da-24618fa52c03'

  # CrudDatabaseName:
  #   Type: String
  #   Default: cruddb
  #   Description: Name of a testing database name

  DisableAppCache:
    Description: 'Disable the redis cache by the backend'
    Type: String
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'

  EnableAdditionalMetrics:
    Description: 'Enable additional CloudFront metrics ($0.30 per metric per distribution)'
    Type: String
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'

  TargetChattyLambdaArn:
    Type: String
    Description: 'ARN of the Lambda function to be invoked by EventBridge'
    Default: ''

  RetainResourcesOnDelete:
    Description: 'Set to true to retain resources on stack deletion or replacement'
    Type: String
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'

Conditions:
  IsLambdaInPrivateSubnet: !Not [!Equals [!Ref ExistingAppPrivateSubnetId, '']]
  HasCustomDomainName: !Not [!Equals [!Ref CustomDomainName, '']]
  HasCertificateArn: !Not [!Equals [!Ref CertificateArn, '']]
  UseCustomDomain: !And
    - !Condition HasCustomDomainName
    - !Condition HasCertificateArn
  EnableAdditionalMetricsCondition: !Equals [!Ref EnableAdditionalMetrics, 'true']
  AllowOnlyCloudfrontOriginCondition: !Equals [!Ref AllowOnlyCloudfrontOrigin, 'true']
  # Lambda Layer ARNs
  CreateRedisClientLayer: !Equals [!Ref ExistingRedisClientLayerArn, '']
  CreateWebsocketsConnectionsLayer: !Equals [!Ref ExistingWebsocketsConnectionsLayerArn, '']
  CreateCommandsHandlersLayer: !Equals [!Ref ExistingCommandsHandlersLayerArn, '']
  CreateDbDataLayer: !Equals [!Ref ExistingDbDataLayerArn, '']
  CreateDocumentUtilsLayer: !Equals [!Ref ExistingDocumentUtilsLayerArn, '']
  HasTargetChattyLambdaArn: !Not [!Equals [!Ref TargetChattyLambdaArn, '']]
  RetainResourcesCondition: !Equals [!Ref RetainResourcesOnDelete, 'true']

Globals:
  Function:
    Timeout: 3 # seconds
    MemorySize: 128
    AssumeRolePolicyDocument: &lambdaTrustPolicy
      Version: '2012-10-17'
      Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
    Tracing: Active

  Api:
    TracingEnabled: true

Resources:
  # ------------------------------------------------------------------------------
  # Lambda layers.
  # ------------------------------------------------------------------------------
  RedisClientLayer:
    Type: AWS::Serverless::LayerVersion
    Condition: CreateRedisClientLayer
    Properties:
      LayerName: !Sub '${AWS::StackName}-RedisClientLayer'
      Description: Redis Layer
      ContentUri: ../backend/RenTracker-service/ecs/layers/redisClient
      CompatibleRuntimes: ['nodejs20.x']

  WebsocketsConnectionsLayer:
    Type: AWS::Serverless::LayerVersion
    Condition: CreateWebsocketsConnectionsLayer
    Properties:
      LayerName: !Sub '${AWS::StackName}-WebsocketsConnectionsLayer'
      Description: Layer for collecting an array [{connection, username}].
      ContentUri: ../backend/websockets/layers/connections
      CompatibleRuntimes: ['nodejs20.x']

  CommandsHandlersLayer:
    Type: AWS::Serverless::LayerVersion
    Condition: CreateCommandsHandlersLayer
    Properties:
      LayerName: !Sub '${AWS::StackName}-CommandsHandlersLayer'
      Description: Layer for processing commands from the frontend.
      ContentUri: ../backend/RenTracker-service/ecs/layers/commandsHandlers
      CompatibleRuntimes: ['nodejs20.x']

  DbDataLayer:
    Type: AWS::Serverless::LayerVersion
    Condition: CreateDbDataLayer
    Properties:
      LayerName: !Sub '${AWS::StackName}-DbDataLayer'
      Description: Layer for accessing the database.
      ContentUri: ../backend/RenTracker-service/ecs/layers/dbData
      CompatibleRuntimes: ['nodejs20.x']

  DocumentUtilsLayer:
    Type: AWS::Serverless::LayerVersion
    Condition: CreateDocumentUtilsLayer
    Properties:
      LayerName: !Sub '${AWS::StackName}-DocumentUtilsLayer'
      Description: Document utilities layer (markdown, uuid, puppeteer)
      ContentUri: ../backend/layers/document-utils
      CompatibleRuntimes: ['nodejs20.x']

  #==========================================================================================================================================================
  # API Gateway
  #==========================================================================================================================================================

  # ------------------------------------------------------------------------------
  # Websockets API
  # ------------------------------------------------------------------------------
  # CORS in AWS::ApiGatewayV2::Api (WebSocket APIs)
  # WebSocket APIs (defined with AWS::ApiGatewayV2::Api) do not directly utilize CORS in the same manner as REST APIs.
  # Here are some key points regarding WebSocket APIs and CORS:
  #   CORS Not Applicable: WebSocket connections are initiated through an HTTP handshake (the initial connection is made using an HTTP request).
  #     However, once the WebSocket connection is established, there's no concept of CORS since data is transmitted over a single long-lived connection.
  #   Authorization and Security: Instead of CORS, you need to manage authorization through the WebSocket API's route-level authorization settings.
  #     For instance, your ConnectRoute and DisconnectRoute can have defined AuthorizationType.
  #   Preflight Requests: WebSocket connections do not typically require preflight OPTIONS requests like REST calls do.

  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub '${AWS::StackName}-WebSocketAPI'
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'

  WebsocketConnect:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'WbscktConnect-${AWS::StackName}'
      CodeUri: ../backend/websockets/connections/
      Handler: connect.handler
      Runtime: nodejs20.x
      Timeout: 10 # seconds
      Layers:
        - !If [CreateRedisClientLayer, !Ref RedisClientLayer, !Ref ExistingRedisClientLayerArn]
        - !Ref ExistingAwsSdkV3LayerArn
        - !If [CreateWebsocketsConnectionsLayer, !Ref WebsocketsConnectionsLayer, !Ref ExistingWebsocketsConnectionsLayerArn]
        - !If [CreateCommandsHandlersLayer, !Ref CommandsHandlersLayer, !Ref ExistingCommandsHandlersLayerArn]
        - !If [CreateDbDataLayer, !Ref DbDataLayer, !Ref ExistingDbDataLayerArn]
      Environment:
        Variables:
          APP_AWS_REGION: !Ref AWS::Region
          STACK_NAME: !Ref AWS::StackName
          # WEBSOCKET_API_URL: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
          REDIS_ADDRESS: !Ref ExistingRedisAddress
          REDIS_PASSWORD: !Ref ExistingRedisPassword # TODO: sse Secrets Manager
          SQS_MESSAGES_TO_CLIENTS_Q_URL: !Ref MessagesToClientsQueue
          APARTMENTS_TABLE_NAME: !Ref ApartmentsTable
          ACTIVITY_TABLE_NAME: !Ref ActivityTable
          SAAS_TENANTS_TABLE_NAME: !Ref SaaSTenantsTable
          ADMIN_USER_ID: !Ref AdminUserId
      VpcConfig: !If
        - IsLambdaInPrivateSubnet
        - SubnetIds: [!Ref ExistingAppPrivateSubnetId]
          SecurityGroupIds: [!Ref ExistingAppSG]
        - !Ref AWS::NoValue
      Role: !GetAtt WebSocketConnectLambdaRole.Arn
      # TracingConfig:
      #   Mode: Active

  WebsocketDisconnect:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'WbscktDisconnect-${AWS::StackName}'
      CodeUri: ../backend/websockets/connections/
      Handler: disconnect.handler
      Runtime: nodejs20.x
      Layers:
        - !If [CreateRedisClientLayer, !Ref RedisClientLayer, !Ref ExistingRedisClientLayerArn]
        - !If [CreateWebsocketsConnectionsLayer, !Ref WebsocketsConnectionsLayer, !Ref ExistingWebsocketsConnectionsLayerArn]
      Environment:
        Variables:
          APP_AWS_REGION: !Ref AWS::Region
          STACK_NAME: !Ref AWS::StackName
          # WEBSOCKET_API_URL: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
          REDIS_ADDRESS: !Ref ExistingRedisAddress
          REDIS_PASSWORD: !Ref ExistingRedisPassword # TODO: sse Secrets Manager
          SQS_MESSAGES_TO_CLIENTS_Q_URL: !Ref MessagesToClientsQueue
      VpcConfig: !If
        - IsLambdaInPrivateSubnet
        - SubnetIds: [!Ref ExistingAppPrivateSubnetId]
          SecurityGroupIds: [!Ref ExistingAppSG]
        - !Ref AWS::NoValue
      Role: !GetAtt WebSocketLambdaElasticacheSQSRole.Arn
      # TracingConfig:
      #   Mode: Active

  # Commands handler of all incoming messages from clients:
  WebsocketCommandsHandler:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'WbscktCommandsHandler-${AWS::StackName}'
      CodeUri: ../backend/websockets/connections/
      Handler: websocketCommandsHandler.handler
      Runtime: nodejs20.x
      Timeout: 5 # seconds
      Layers:
        - !If [CreateRedisClientLayer, !Ref RedisClientLayer, !Ref ExistingRedisClientLayerArn]
        - !Ref ExistingAwsSdkV3LayerArn
        - !If [CreateWebsocketsConnectionsLayer, !Ref WebsocketsConnectionsLayer, !Ref ExistingWebsocketsConnectionsLayerArn]
        - !If [CreateCommandsHandlersLayer, !Ref CommandsHandlersLayer, !Ref ExistingCommandsHandlersLayerArn]
        - !If [CreateDbDataLayer, !Ref DbDataLayer, !Ref ExistingDbDataLayerArn]
      Environment:
        Variables:
          APP_AWS_REGION: !Ref AWS::Region
          STACK_NAME: !Ref AWS::StackName
          # WEBSOCKET_API_URL: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
          REDIS_ADDRESS: !Ref ExistingRedisAddress
          REDIS_PASSWORD: !Ref ExistingRedisPassword # TODO: sse Secrets Manager
          SQS_MESSAGES_TO_CLIENTS_Q_URL: !Ref MessagesToClientsQueue
          ADMIN_USER_ID: !Ref AdminUserId
          APARTMENTS_TABLE_NAME: !Ref ApartmentsTable
          ACTIVITY_TABLE_NAME: !Ref ActivityTable
          SAAS_TENANTS_TABLE_NAME: !Ref SaaSTenantsTable
          ENABLE_ENHANCED_LOGGING: false
          DISABLE_APP_CACHE: !Ref DisableAppCache
      VpcConfig: !If
        - IsLambdaInPrivateSubnet
        - SubnetIds: [!Ref ExistingAppPrivateSubnetId]
          SecurityGroupIds: [!Ref ExistingAppSG]
        - !Ref AWS::NoValue
      Role: !GetAtt WebsocketCommandsHandlerLambdaRole.Arn
      # TracingConfig:
      #   Mode: Active

  WebsocketCommandsHandlerIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      Description: WebsocketCommandsHandler Function Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebsocketCommandsHandler.Arn}/invocations

  WebsocketCommandsHandlerRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: CommandsHandlerRouteKey
      OperationName: WebsocketCommandsHandlerRoute
      Target: !Join
        - '/'
        - ['integrations', !Ref WebsocketCommandsHandlerIntegration]

  ElasticacheSQSPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - elasticache:Connect
              - elasticache:DescribeCacheClusters
              - sqs:SendMessage
            Resource: '*'

  WebSocketLambdaElasticacheSQSRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - !Ref ElasticacheSQSPolicy

  WebSocketConnectLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
        - !Ref ElasticacheSQSPolicy
      Policies:
        - PolicyName: WebSocketManageConnections
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'execute-api:ManageConnections'
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'
        - PolicyName: DDBAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                Resource:
                  - !Sub '${ApartmentsTable.Arn}/index/SaaSTenantUpdatedIndex'
                  - !Sub '${ActivityTable.Arn}/index/ApartmentCreatedIndex'
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                Resource:
                  - !GetAtt SaaSTenantsTable.Arn

  WebsocketCommandsHandlerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
        - !Ref ElasticacheSQSPolicy
      Policies:
        - PolicyName: DDBAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                Resource:
                  - !GetAtt ApartmentsTable.Arn
                  - !GetAtt ActivityTable.Arn
                  - !GetAtt SaaSTenantsTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:Query
                Resource:
                  - !Sub '${ActivityTable.Arn}/index/ApartmentCreatedIndex'
              - Effect: Allow
                Action:
                  - dynamodb:Scan
                  - dynamodb:GetItem
                Resource:
                  - !GetAtt SaaSTenantsTable.Arn

  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      Description: WebsocketConnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebsocketConnect.Arn}/invocations

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      Description: WebsocketDisconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebsocketDisconnect.Arn}/invocations

  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      OperationName: ConnectRoute
      Target: !Join
        - '/'
        - ['integrations', !Ref ConnectIntegration]

  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - ['integrations', !Ref DisconnectIntegration]

  WebSocketDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
      - ConnectRoute
      - DisconnectRoute
    Properties:
      ApiId: !Ref WebSocketApi

  WebSocketLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${AWS::StackName}-websocket-${WebSocketApi}/access-logs/'
      RetentionInDays: 1

  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: !Ref StageName
      AutoDeploy: false
      DeploymentId: !Ref WebSocketDeployment
      DefaultRouteSettings:
        DetailedMetricsEnabled: true
        LoggingLevel: ERROR
      AccessLogSettings:
        DestinationArn: !GetAtt WebSocketLogGroup.Arn
        Format: '{ "requestId":"$context.requestId", "ip": "$context.identity.sourceIp", "caller":"$context.identity.caller", "user":"$context.identity.user", "requestTime":"$context.requestTime", "eventType":"$context.eventType", "routeKey":"$context.routeKey", "status":"$context.status", "connectionId":"$context.connectionId" }'

  # AWS::Lambda::Permission resources are specifically required to grant permissions to other AWS services (in this case, API Gateway) to invoke your Lambda functions.
  # These permissions are necessary because, by default, Lambda functions are not accessible to other AWS services.
  # We need to explicitly allow API Gateway to invoke WebsocketConnect and WebsocketDisconnect.

  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebsocketConnect
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/$connect'

  DisconnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebsocketDisconnect
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/$disconnect'

  WebsocketCommandsHandlerPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebsocketCommandsHandler
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/CommandsHandlerRouteKey'

  #==========================================================================================================================================================
  # RESTful API
  #==========================================================================================================================================================
  RestApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${AWS::StackName}-rest/${StageName}/access-logs/'
      RetentionInDays: 1

  RestApi:
    Type: AWS::Serverless::Api
    Properties:
      Name: !Sub '${AWS::StackName}-RestAPI'
      StageName: !Ref StageName
      BinaryMediaTypes: ['multipart/form-data'] # Treat multipart/form-data as binary and base64-encode the raw request body before sending to Lambda
      Cors:
        AllowMethods: !Ref ApiGatewayCorsAllowedMethods
        AllowHeaders: !Ref ApiGatewayCorsAllowedHeaders
        AllowOrigin: !Ref ApiGatewayCorsAllowedOrigins
      Auth:
        DefaultAuthorizer: CognitoAuthorizer
        Authorizers:
          CognitoAuthorizer:
            UserPoolArn: !Sub 'arn:aws:cognito-idp:${AWS::Region}:${AWS::AccountId}:userpool/${ExistingUserPoolId}'
        AddDefaultAuthorizerToCorsPreflight: false
      GatewayResponses:
        DEFAULT_4XX:
          ResponseParameters:
            Headers:
              Access-Control-Allow-Methods: !Ref ApiGatewayCorsAllowedMethods
              Access-Control-Allow-Headers: !Ref ApiGatewayCorsAllowedHeaders
              Access-Control-Allow-Origin: !Ref ApiGatewayCorsAllowedOrigins
        DEFAULT_5XX:
          ResponseParameters:
            Headers:
              Access-Control-Allow-Methods: !Ref ApiGatewayCorsAllowedMethods
              Access-Control-Allow-Headers: !Ref ApiGatewayCorsAllowedHeaders
              Access-Control-Allow-Origin: !Ref ApiGatewayCorsAllowedOrigins
      AccessLogSetting:
        DestinationArn: !GetAtt RestApiLogGroup.Arn
        Format: '{ "requestId":"$context.requestId", "ip":"$context.identity.sourceIp", "caller":"$context.identity.caller", "user":"$context.identity.user", "requestTime":"$context.requestTime", "httpMethod":"$context.httpMethod", "resourcePath":"$context.resourcePath", "status":"$context.status", "protocol":"$context.protocol", "responseLength":"$context.responseLength" }'

  # API Deployment
  RestApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref RestApi

  DocumentsRestFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'DocumentsRestFunction-${AWS::StackName}'
      CodeUri: ../backend/documents/
      Handler: documents.handler
      Runtime: nodejs20.x
      Timeout: 300 # seconds
      MemorySize: 2048
      Layers:
        - !Ref ExistingCorsHeadersLayerArn
        - !If [CreateDbDataLayer, !Ref DbDataLayer, !Ref ExistingDbDataLayerArn]
        - !If [CreateRedisClientLayer, !Ref RedisClientLayer, !Ref ExistingRedisClientLayerArn]
        - !If [CreateDocumentUtilsLayer, !Ref DocumentUtilsLayer, !Ref ExistingDocumentUtilsLayerArn]
        - !Ref ExistingAwsSdkV3LayerArn
      Environment:
        Variables:
          STACK_NAME: !Ref AWS::StackName
          REDIS_ADDRESS: !Ref ExistingRedisAddress
          REDIS_PASSWORD: !Ref ExistingRedisPassword # TODO: sse Secrets Manager
          ALLOWED_ORIGIN: !If
            - AllowOnlyCloudfrontOriginCondition
            - !Sub 'https://${FrontendDistribution.DomainName}'
            - !Ref ApiGatewayCorsAllowedOrigins
          APP_AWS_REGION: !Ref AWS::Region
          DOCUMENTS_TABLE_NAME: !Ref DocumentsTable
          DOCUMENTS_BUCKET_NAME: !Ref DocumentsBucket
          DOCUMENTS_CLOUDFRONT_DOMAIN: !GetAtt DocumentsDistribution.DomainName
          SQS_MESSAGES_TO_CLIENTS_Q_URL: !Ref MessagesToClientsQueue
      Role: !GetAtt DocumentsRestFunctionExecutionRole.Arn
      Events:
        CreateDocument:
          Type: Api
          Properties:
            Path: /documents
            Method: POST
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        GetDocument:
          Type: Api
          Properties:
            Path: /documents/{documentId}
            Method: GET
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        GetDocumentPdf:
          Type: Api
          Properties:
            Path: /documents/{documentId}/pdf
            Method: GET
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        ListDocuments:
          Type: Api
          Properties:
            Path: /documents
            Method: GET
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        UpdateDocument:
          Type: Api
          Properties:
            Path: /documents/{documentId}
            Method: PUT
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        DeleteDocument:
          Type: Api
          Properties:
            Path: /documents/{documentId}
            Method: DELETE
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
        UploadFile:
          Type: Api
          Properties:
            Path: /upload
            Method: POST
            RestApiId: !Ref RestApi
            Auth:
              Authorizer: CognitoAuthorizer
      VpcConfig: !If
        - IsLambdaInPrivateSubnet
        - SubnetIds: [!Ref ExistingAppPrivateSubnetId]
          SecurityGroupIds: [!Ref ExistingAppSG]
        - !Ref AWS::NoValue
      # TracingConfig:
      #   Mode: Active

  DocumentsRestFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
        - !Ref ElasticacheSQSPolicy
      Policies:
        - PolicyName: DocumentsTableAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                Resource:
                  - !Sub '${DocumentsTable.Arn}/index/ApartmentUpdatedIndex'
                  - !Sub '${DocumentsTable.Arn}/index/TenantUpdatedIndex'
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:GetItem
                Resource:
                  - !GetAtt DocumentsTable.Arn
        - PolicyName: S3UrlsPresigningPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub 'arn:aws:s3:::${DocumentsBucket}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub 'arn:aws:s3:::${DocumentsBucket}'
        - PolicyName: S3FilesUploadingPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource:
                  - !Sub 'arn:aws:s3:::${DocumentsBucket}/*'

  DocumentsStreamProcessor:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'DocumentsStreamProcessor-${AWS::StackName}'
      CodeUri: ../backend/documents/
      Handler: documentsStreamProcessor.handler
      Runtime: nodejs20.x
      Timeout: 60 # seconds
      MemorySize: 2048
      Layers:
        - !Ref ExistingAwsSdkV3LayerArn
        - !If [CreateDocumentUtilsLayer, !Ref DocumentUtilsLayer, !Ref ExistingDocumentUtilsLayerArn]
        - !If [CreateRedisClientLayer, !Ref RedisClientLayer, !Ref ExistingRedisClientLayerArn]
        - !If [CreateDbDataLayer, !Ref DbDataLayer, !Ref ExistingDbDataLayerArn]
      Environment:
        Variables:
          STACK_NAME: !Ref AWS::StackName
          REDIS_ADDRESS: !Ref ExistingRedisAddress
          REDIS_PASSWORD: !Ref ExistingRedisPassword # TODO: sse Secrets Manager
          DOCUMENTS_BUCKET_NAME: !Ref DocumentsBucket
          # DOCUMENTS_CLOUDFRONT_DISTRIBUTION_ID: !Ref DocumentsDistribution
      Role: !GetAtt DocumentsStreamProcessorExecutionRole.Arn
      VpcConfig: !If
        - IsLambdaInPrivateSubnet
        - SubnetIds: [!Ref ExistingAppPrivateSubnetId]
          SecurityGroupIds: [!Ref ExistingAppSG]
        - !Ref AWS::NoValue
      Events:
        DocumentsTableStream:
          Type: DynamoDB
          Properties:
            Stream: !GetAtt DocumentsTable.StreamArn
            BatchSize: 10
            StartingPosition: LATEST
            Enabled: true
      # TracingConfig:
      #   Mode: Active

  DocumentsStreamProcessorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
      Policies:
        - PolicyName: S3InvalidateAndRefreshPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub 'arn:aws:s3:::${DocumentsBucket}'
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub 'arn:aws:s3:::${DocumentsBucket}/*'
              # - Effect: Allow
              #   Action:
              #     - cloudfront:CreateInvalidation
              #   Resource: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${DocumentsDistribution}'
        - PolicyName: DynamoDBStreamAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetRecords
                  - dynamodb:GetShardIterator
                  - dynamodb:DescribeStream
                  - dynamodb:ListStreams
                Resource: !GetAtt DocumentsTable.StreamArn

  #==========================================================================================================================================================
  # Cognito
  #==========================================================================================================================================================
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref ExistingUserPoolId
      ClientName: !Sub '${AWS::StackName}-UserPoolClient'
      GenerateSecret: false
      AllowedOAuthFlows: ['code']
      AllowedOAuthScopes: ['phone', 'email', 'openid', 'profile']
      AllowedOAuthFlowsUserPoolClient: true
      CallbackURLs:
        - !If
          - UseCustomDomain
          - !Sub 'https://${CustomDomainName}'
          - !Sub 'https://${FrontendDistribution.DomainName}'
        - 'http://localhost:3000'
      LogoutURLs:
        - !If
          - UseCustomDomain
          - !Sub 'https://${CustomDomainName}'
          - !Sub 'https://${FrontendDistribution.DomainName}'
        - 'http://localhost:3000'
      SupportedIdentityProviders: ['Google']

  # ------------------------------------------------------------------------------
  # DynamoDB Tables.
  # ------------------------------------------------------------------------------

  SaaSTenantsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: !If [RetainResourcesCondition, Retain, Delete]
    UpdateReplacePolicy: !If [RetainResourcesCondition, Retain, Delete]
    Properties:
      TableName: !Sub 'SaaSTenants-${AWS::StackName}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: saas_tenant_id
          AttributeType: S
      KeySchema:
        - AttributeName: saas_tenant_id
          KeyType: HASH # Partition key

  ApartmentsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: !If [RetainResourcesCondition, Retain, Delete]
    UpdateReplacePolicy: !If [RetainResourcesCondition, Retain, Delete]
    Properties:
      TableName: !Sub 'Apartments-${AWS::StackName}'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: apartment_id
          AttributeType: S
        - AttributeName: updated_at
          AttributeType: S
        - AttributeName: saas_tenant_id
          AttributeType: S
      KeySchema:
        - AttributeName: apartment_id
          KeyType: HASH # Partition key
      GlobalSecondaryIndexes:
        - IndexName: SaaSTenantUpdatedIndex
          KeySchema:
            - AttributeName: saas_tenant_id
              KeyType: HASH # Partition key
            - AttributeName: updated_at
              KeyType: RANGE # Sort key
          Projection:
            ProjectionType: ALL

  DocumentsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: !If [RetainResourcesCondition, Retain, Delete]
    UpdateReplacePolicy: !If [RetainResourcesCondition, Retain, Delete]
    Properties:
      TableName: !Sub 'Documents-${AWS::StackName}'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      AttributeDefinitions:
        - AttributeName: document_id
          AttributeType: S
        - AttributeName: apartment_id
          AttributeType: S
        - AttributeName: updated_at
          AttributeType: S
        - AttributeName: tenant_user_id
          AttributeType: S
        # - AttributeName: saas_tenant_id
        #   AttributeType: S
      KeySchema:
        - AttributeName: document_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: ApartmentUpdatedIndex
          KeySchema:
            - AttributeName: apartment_id
              KeyType: HASH # Partition key
            - AttributeName: updated_at
              KeyType: RANGE # Sort key
          Projection:
            ProjectionType: ALL
        - IndexName: TenantUpdatedIndex
          KeySchema:
            - AttributeName: tenant_user_id
              KeyType: HASH # Partition key
            - AttributeName: updated_at
              KeyType: RANGE # Sort key
          Projection:
            ProjectionType: ALL
        # - IndexName: SaaSTenantUpdatedIndex
        #   KeySchema:
        #     - AttributeName: saas_tenant_id
        #       KeyType: HASH # Partition key
        #     - AttributeName: updated_at
        #       KeyType: RANGE # Sort key
        #   Projection:
        #     ProjectionType: ALL

  ActivityTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: !If [RetainResourcesCondition, Retain, Delete]
    UpdateReplacePolicy: !If [RetainResourcesCondition, Retain, Delete]
    Properties:
      TableName: !Sub 'ApartmentActivity-${AWS::StackName}'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: activity_id
          AttributeType: S
        - AttributeName: created_at
          AttributeType: S
        - AttributeName: apartment_id
          AttributeType: S
        # - AttributeName: saas_tenant_id
        #   AttributeType: S
      KeySchema:
        - AttributeName: activity_id
          KeyType: HASH # Partition key
      GlobalSecondaryIndexes:
        - IndexName: ApartmentCreatedIndex
          KeySchema:
            - AttributeName: apartment_id
              KeyType: HASH # Partition key
            - AttributeName: created_at
              KeyType: RANGE # Sort key
          Projection:
            ProjectionType: ALL
        # - IndexName: SaaSTenantCreatedIndex
        #   KeySchema:
        #     - AttributeName: saas_tenant_id
        #       KeyType: HASH # Partition key
        #     - AttributeName: created_at
        #       KeyType: RANGE # Sort key
        #   Projection:
        #     ProjectionType: ALL

  #==========================================================================================================================================================
  # SQS
  #==========================================================================================================================================================
  MessagesToClientsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-messagesToClientsQ'
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt MessagesToClientsDLQ.Arn
        maxReceiveCount: 5 # Adjust the max receive count as needed

  MessagesToClientsDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-messagesToClientsDLQ'

  WebsocketEventsHandler:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub 'WbscktEventsHandler-${AWS::StackName}'
      Handler: websocketEventsHandler.handler
      Runtime: nodejs20.x
      Timeout: 10 # seconds
      CodeUri: ../backend/websockets/connections/
      Layers:
        - !Ref ExistingAwsSdkV3LayerArn
        - !If [CreateWebsocketsConnectionsLayer, !Ref WebsocketsConnectionsLayer, !Ref ExistingWebsocketsConnectionsLayerArn]
      Environment:
        Variables:
          WEBSOCKET_API_URL: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
          APP_AWS_REGION: !Ref AWS::Region
          STACK_NAME: !Ref AWS::StackName
          ENABLE_ENHANCED_LOGGING: true
          SQS_MESSAGES_TO_CLIENTS_Q_URL: !Ref MessagesToClientsQueue
          SES_SOURCE_EMAIL: 'webcharm.tech@gmail.com'
          DOCUMENTS_CLOUDFRONT_DISTRIBUTION_ID: !Ref DocumentsDistribution
      Role: !GetAtt WebsocketEventsHandlerExecutionRole.Arn
      Events: # event source mapping
        SQSTrigger:
          Type: SQS
          Properties:
            Queue: !GetAtt MessagesToClientsQueue.Arn
            BatchSize: 10
            Enabled: true
      # TracingConfig:
      #   Mode: Active

  WebsocketEventsHandlerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument: *lambdaTrustPolicy
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess'
      Policies:
        - PolicyName: SQSReceiveMessagePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt MessagesToClientsQueue.Arn
        - PolicyName: WebSocketManageConnections
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'execute-api:ManageConnections'
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'
        - PolicyName: EventBridgePublishPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - events:PutEvents
                Resource: !GetAtt CommandsEventBus.Arn
        - PolicyName: SESEmailVerificationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ses:GetEmailIdentity
                  - ses:CreateEmailIdentity
                Resource: !Sub 'arn:aws:ses:${AWS::Region}:${AWS::AccountId}:identity/*'
        - PolicyName: SESEmailSendingPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: '*'
        - PolicyName: S3InvalidatePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudfront:CreateInvalidation
                Resource: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${DocumentsDistribution}'

  #==========================================================================================================================================================
  # EventBridge Resources
  #==========================================================================================================================================================
  CommandsEventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !Sub '${AWS::StackName}-commands-event-bus'

  EventBridgeRules:
    Type: AWS::Events::Rule
    Condition: HasTargetChattyLambdaArn
    Properties:
      EventBusName: !Ref CommandsEventBus
      EventPattern:
        source:
          - 'RENTracker-service' # An identifier that needs to match exactly with the Source field we specify when publishing events
        detail-type:
          - 'command-executed'
        detail: # This rule will trigger the target Lambda when:
          # 1. The event source is 'RENTracker-service'
          # 2. The detail-type is 'command-executed'
          # 3. The event detail matches either conditions:
          $or:
            - dataUpdated:
                apartments:
                  is_disabled:
                    - false
            - dataCreated:
                activity:
                  pending_confirmation:
                    - true
            - dataCreated:
                saasTenants:
                  is_disabled:
                    - false
      State: ENABLED
      Targets:
        - Arn: !Ref TargetChattyLambdaArn
          Id: 'TargetLambda'

  TargetLambdaPermission:
    Type: AWS::Lambda::Permission
    Condition: HasTargetChattyLambdaArn
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref TargetChattyLambdaArn
      Principal: events.amazonaws.com
      SourceArn: !GetAtt EventBridgeRules.Arn

  # ------------------------------------------------------------------------------
  # S3 web site and cloudfront
  # ------------------------------------------------------------------------------

  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${AWS::StackName}-frontend-${AWS::AccountId}
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: ['GET']
            AllowedOrigins: ['*']
            MaxAge: 3000
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      OwnershipControls:
        Rules:
          - ObjectOwnership: ObjectWriter

  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: '*'
            Action: 's3:GetObject'
            Resource: !Sub '${FrontendBucket.Arn}/*'

  FrontendDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: S3Origin
            DomainName: !Select [1, !Split ['//', !GetAtt FrontendBucket.WebsiteURL]]
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: http-only
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: ['GET', 'HEAD', 'OPTIONS']
          CachedMethods: ['GET', 'HEAD']
          ForwardedValues:
            QueryString: false
            Headers: ['Origin']
          MinTTL: 0
          DefaultTTL: 86400
          MaxTTL: 31536000
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 0
        ViewerCertificate: !If
          - UseCustomDomain
          - AcmCertificateArn: !Ref CertificateArn
            SslSupportMethod: sni-only
          - CloudFrontDefaultCertificate: true
        PriceClass: PriceClass_100
        Enabled: true
        Aliases: !If
          - UseCustomDomain
          - [!Ref CustomDomainName]
          - !Ref AWS::NoValue

  FrontendDistributionMetrics:
    Type: AWS::CloudFront::MonitoringSubscription
    Condition: EnableAdditionalMetricsCondition
    Properties:
      DistributionId: !Ref FrontendDistribution
      MonitoringSubscription:
        RealtimeMetricsSubscriptionConfig:
          RealtimeMetricsSubscriptionStatus: Enabled

  DocumentsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub ${AWS::StackName}-documents-${AWS::AccountId}
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: ['GET']
            AllowedOrigins: ['*']
            MaxAge: 3000
      OwnershipControls:
        Rules:
          - ObjectOwnership: ObjectWriter
      LifecycleConfiguration:
        Rules:
          - Id: MoveDocumentsToIA
            Status: Enabled
            Transitions:
              - StorageClass: STANDARD_IA
                TransitionInDays: 30

  DocumentsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref DocumentsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          # Allow CloudFront to access S3 when requests include valid pre-signed URL parameters
          # This ensures only authenticated requests via CloudFront can access the private bucket
          - Sid: AllowCloudfrontPresignedUrlsAccess
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: 's3:GetObject'
            Resource: !Sub '${DocumentsBucket.Arn}/*'
            Condition:
              StringEqualsIfExists:
                s3:signatureversion: 'AWS4-HMAC-SHA256'

  # Cache policy: Determines what CloudFront uses as cache key
  # - Ignores all query parameters (including auth) for better cache hits
  # - Files with same path are served from cache regardless of auth parameters
  # - TTL controls how long files stay in CloudFront cache
  DocumentsCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: !Sub ${AWS::StackName}-documents-cache
        DefaultTTL: 86400 # 24 hours
        MaxTTL: 31536000 # 365 days
        MinTTL: 0
        ParametersInCacheKeyAndForwardedToOrigin:
          EnableAcceptEncodingGzip: true
          CookiesConfig:
            CookieBehavior: none
          HeadersConfig:
            HeaderBehavior: none
          QueryStringsConfig: # See 'Ignores all query parameters' comment above
            QueryStringBehavior: none

  # Origin request policy: Controls what CloudFront forwards to S3
  # - Forwards ALL query parameters to S3 including pre-signed URL auth parameters
  # - This ensures S3 can authenticate the request while CloudFront still uses cache
  # - Separates caching (above policy) from authentication (this policy)
  DocumentsOriginRequestPolicy:
    Type: AWS::CloudFront::OriginRequestPolicy
    Properties:
      OriginRequestPolicyConfig:
        Name: !Sub ${AWS::StackName}-documents-origin
        QueryStringsConfig: # See 'Forwards ALL query parameters' comment above
          QueryStringBehavior: all
        HeadersConfig:
          HeaderBehavior: whitelist
          Headers: ['Origin']
        CookiesConfig:
          CookieBehavior: none

  DocumentsDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - Id: DocumentsS3Origin
            DomainName: !GetAtt DocumentsBucket.RegionalDomainName
            CustomOriginConfig:
              HTTPPort: 80
              HTTPSPort: 443
              OriginProtocolPolicy: http-only
        DefaultCacheBehavior:
          TargetOriginId: DocumentsS3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: ['GET', 'HEAD']
          CachedMethods: ['GET', 'HEAD']
          CachePolicyId: !Ref DocumentsCachePolicy
          OriginRequestPolicyId: !Ref DocumentsOriginRequestPolicy
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
        PriceClass: PriceClass_100
        Enabled: true

  DocumentsDistributionMetrics:
    Type: AWS::CloudFront::MonitoringSubscription
    Condition: EnableAdditionalMetricsCondition
    Properties:
      DistributionId: !Ref DocumentsDistribution
      MonitoringSubscription:
        RealtimeMetricsSubscriptionConfig:
          RealtimeMetricsSubscriptionStatus: Enabled

Outputs:
  WebSocketApiUrl:
    Description: 'URL for the WebSocket API Gateway'
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'
  RestApiUrl:
    Description: 'URL for the REST API Gateway'
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}'

  UserPoolId:
    Description: 'Cognito User Pool ID'
    Value: !Ref ExistingUserPoolId
  UserPoolClientId:
    Description: 'Cognito User Pool Client ID'
    Value: !Ref UserPoolClient
  CognitoDomain:
    Description: 'Cognito User Pool Domain'
    Value: !Ref ExistingCognitoDomain

  S3BucketName:
    Description: 'Name of the S3 bucket hosting the frontend'
    Value: !Ref FrontendBucket
  CloudFrontUrl:
    Description: 'CloudFront distribution URL'
    Value: !Sub 'https://${FrontendDistribution.DomainName}'
  CloudFrontDistributionId:
    Description: 'CloudFront distribution ID'
    Value: !Ref FrontendDistribution

  AllowOnlyCloudfrontOrigin:
    Description: 'Allow HTTP access only through CloudFront'
    Value: !If [AllowOnlyCloudfrontOriginCondition, 'true', 'false']
